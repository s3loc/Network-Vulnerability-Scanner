 """
⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⡴⠋⠉⡊⢁⠀⠀⢬⠀⠉⠋⠈⠥⠤⢍⡛⠒⠶⣄⡀⠀⠀⠀
⠀⠀⠀⠀⣾⠥⠀⠀⠊⢭⣾⣿⣷⡤⠀⣠⡀⡅⢠⣶⣮⣄⠉⠢⠙⡆⠀⠀
⠀⠀⣠⡾⣁⡨⠴⠢⡤⣿⣿⣿⣿⣿⠸⡷⠙⣟⠻⣯⣿⣟⣃⣠⡁⢷⣄⠀
⠀⡼⡙⣜⡕⠻⣷⣦⡀⢙⠝⠛⡫⢵⠒⣀⡀⠳⡲⢄⣀⢰⣫⣶⡇⡂⠙⡇
⢸⡅⡇⠈⠀⠀⠹⣿⣿⣷⣷⣾⣄⣀⣬⣩⣷⠶⠧⣶⣾⣿⣿⣿⡷⠁⣇⡇
⠀⠳⣅⢀⢢⠡⠀⡜⢿⣿⣿⡏⠑⡴⠙⣤⠊⠑⡴⠁⢻⣿⣿⣿⠇⢀⡞⠀
⠀⠀⠘⢯⠀⡆⠀⠐⡨⡻⣿⣧⣤⣇⣀⣧⣀⣀⣷⣠⣼⣿⣿⣿⠀⢿⠀⠀
⠀⠀⠀⠈⢧⡐⡄⠀⠐⢌⠪⡻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡄⢸⠀⠀
⠀⠀⠀⠀⠀⠙⢾⣆⠠⠀⡁⠘⢌⠻⣿⣿⠻⠹⠁⢃⢹⣿⣿⣿⡇⡘⡇⠀
⠀⠀⠀⠀⠀⠀⠀⠈⠛⠷⢴⣄⠀⢭⡊⠛⠿⠿⠵⠯⡭⠽⣛⠟⢡⠃⡇⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠲⠬⣥⣀⡀⠀⢀⠀⠀⣠⡲⢄⡼⠃⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠙⠓⠒⠒⠒⠋⠉⠀⠀⠀


AS I AM A JUNIOR LEVEL PROGRAMMER, DO NOT TAKE MY MISTAKES TOO SERIOUSLY, PLEASE CONTACT ME WITH MY MISTAKES -s3loc_


DISCLAIMER OF LIABILITY:

The author(s) of this code accept no responsibility or liability for any damages or issues arising from the use or misuse of this code. Use this code at your own risk. By using this code, 
you agree that the author(s) are not responsible for any consequences or harm that may occur, whether direct or indirect, as a result of using this code. 

This code is provided "as is" without any warranties or guarantees. The user assumes all responsibility for ensuring the suitability of this code for their specific needs and requirements.
 """











import sys
import requests
from bs4 import BeautifulSoup
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
                             QProgressBar, QTextEdit, QLineEdit, QMessageBox, QMenu, QAction)
from PyQt5.QtGui import QFont, QContextMenuEvent, QCursor
from PyQt5.QtCore import QThread, pyqtSignal, Qt
from urllib.parse import urljoin


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle('Vulnerability Scanner')
        self.setGeometry(100, 100, 800, 600)
        self.setStyleSheet("background-color: #121212; color: #FFAFFF;")  # Dark theme
        self.worker = ScanWorker()
        self.worker.finished.connect(self.scan_finished)
        self.worker.progress.connect(self.update_progress)
        self.setCentralWidget(self.create_main_layout())

    def create_main_layout(self):
        main_layout = QVBoxLayout()

        title_label = QLabel('Vulnerability Scanner')
        title_label.setFont(QFont('Arial', 18, QFont.Bold))
        title_label.setStyleSheet("color: #00FF00; margin-bottom: 20px;")  # Neon green
        main_layout.addWidget(title_label, alignment=Qt.AlignCenter)

        url_layout = QHBoxLayout()
        url_label = QLabel('Enter Target URL:')
        url_label.setFont(QFont('Arial', 14))
        url_label.setStyleSheet("color: #FFFFFF;")

        self.url_input = QLineEdit()
        self.url_input.setPlaceholderText('http://example.com')
        self.url_input.setStyleSheet("""
            QLineEdit {
                border: 1px solid #333;
                border-radius: 5px;
                padding: 5px;
                font-size: 14px;
                background-color: #222;
                color: #FFFFFF;
            }
        """)

        self.attack_button = self.create_button('Attack', self.start_attack)
        self.scan_button = self.create_button('Scan', self.start_scan)

        url_layout.addWidget(url_label)
        url_layout.addWidget(self.url_input)
        url_layout.addWidget(self.attack_button)
        url_layout.addWidget(self.scan_button)
        main_layout.addLayout(url_layout)

        self.progress_label = QLabel('Progress:')
        self.progress_label.setFont(QFont('Arial', 14))
        self.progress_label.setStyleSheet("color: #FFFFFF;")
        main_layout.addWidget(self.progress_label)

        self.progress_bar = QProgressBar()
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(100)
        self.progress_bar.setValue(0)
        self.progress_bar.setStyleSheet("""
            QProgressBar {
                border: 2px solid #333;
                border-radius: 5px;
                text-align: center;
                background-color: #222;
            }
            QProgressBar::chunk {
                background: #00FF00;
                width: 20px;
            }
        """)
        main_layout.addWidget(self.progress_bar)

        results_label = QLabel('Results:')
        results_label.setFont(QFont('Arial', 14))
        results_label.setStyleSheet("color: #FFFFFF;")
        main_layout.addWidget(results_label)

        self.results_text = QTextEdit()
        self.results_text.setStyleSheet("""
            QTextEdit {
                border: 1px solid #333;
                border-radius: 5px;
                padding: 5px;
                font-size: 14px;
                background-color: #222;
                color: #FFFFFF;
            }
        """)
        main_layout.addWidget(self.results_text)

        container = QWidget()
        container.setLayout(main_layout)

        return container

    def create_button(self, text, callback):
        button = QPushButton(text)
        button.clicked.connect(callback)
        button.setStyleSheet("""
            QPushButton {
                background-color: #00FF00;
                border: none;
                color: white;
                padding: 10px 20px;
                text-align: center;
                text-decoration: none;
                display: inline-block;
                font-size: 16px;
                margin: 4px 2px;
                cursor: pointer;
                border-radius: 5px;
                transition: background-color 0.3s ease;
            }
            QPushButton:hover {
                background-color: #00CC00;
            }
        """)
        return button

    def contextMenuEvent(self, event: QContextMenuEvent):
        context_menu = QMenu(self)
        show_vulnerabilities_action = QAction('Show Vulnerabilities', self)
        show_vulnerabilities_action.triggered.connect(self.show_vulnerabilities)
        context_menu.addAction(show_vulnerabilities_action)
        context_menu.exec_(QCursor.pos())

    def show_vulnerabilities(self):
        url = self.url_input.text().strip()
        if not url.startswith('http'):
            url = 'http://' + url

        if not url:
            QMessageBox.warning(self, 'Warning', 'URL cannot be empty!')
            return

        # Here, you can add the logic to display vulnerabilities.
        QMessageBox.information(self, 'Vulnerabilities', 'List of vulnerabilities for the URL will be displayed here.')

    def start_attack(self):
        url = self.url_input.text().strip()
        if not url.startswith('http'):
            url = 'http://' + url

        if not url:
            QMessageBox.warning(self, 'Warning', 'URL cannot be empty!')
            return

        self.attack_button.setEnabled(False)
        self.results_text.clear()
        self.progress_bar.setValue(0)

        self.worker.set_url(url)
        self.worker.start()

    def start_scan(self):
        self.start_attack()

    def update_progress(self, value):
        self.progress_bar.setValue(value)

    def scan_finished(self, vulnerabilities):
        self.attack_button.setEnabled(True)
        self.display_results(vulnerabilities)

    def display_results(self, vulnerabilities):
        if vulnerabilities:
            result_text = "Vulnerabilities found:\n\n"
            for vuln in vulnerabilities:
                result_text += f"Vulnerability Type: {vuln['Vulnerability Type']}\n"
                result_text += f"Target URL: {vuln['Target URL']}\n"
                result_text += f"Details:\n"
                result_text += f"  Payload: {vuln.get('Payload', '')}\n"
                result_text += f"  Response:\n{vuln['Response']}\n\n"
        else:
            result_text = "No vulnerabilities found."

        self.results_text.setPlainText(result_text)


class ScanWorker(QThread):
    finished = pyqtSignal(list)
    progress = pyqtSignal(int)

    def __init__(self):
        super().__init__()
        self.url = ""

    def set_url(self, url):
        self.url = url

    def run(self):
        vulnerabilities = []
        try:
            response = requests.get(self.url)
            response.raise_for_status()
            soup = BeautifulSoup(response.text, 'html.parser')
            forms = soup.find_all('form')

            total_forms = len(forms)
            if total_forms == 0:
                self.progress.emit(100)
                self.finished.emit(vulnerabilities)
                return

            for i, form in enumerate(forms):
                form_details = self.get_form_details(form)
                self.check_vulnerabilities(form_details, vulnerabilities)
                progress = int((i + 1) / total_forms * 100)
                self.progress.emit(progress)

            self.progress.emit(100)
            self.finished.emit(vulnerabilities)
        except requests.RequestException as e:
            self.progress.emit(100)
            self.finished.emit([{'Vulnerability Type': 'Error', 'Target URL': self.url, 'Response': str(e)}])

    def get_form_details(self, form):
        details = {}
        details['method'] = form.get('method', 'GET').upper()
        details['action'] = form.get('action', '')
        details['inputs'] = [{'name': input.get('name', ''), 'type': input.get('type', 'text')} for input in form.find_all('input')]
        return details

    def check_vulnerabilities(self, form_details, vulnerabilities):
        base_url = self.url
        if not base_url.endswith('/'):
            base_url += '/'

        action_url = urljoin(base_url, form_details['action'])
        test_payload = {'test': 'test'}

        # Test for session fixation
        self.check_session_fixation(action_url, form_details, test_payload, vulnerabilities)

        # Test for predictable login credentials
        self.check_predictable_login_credentials(action_url, form_details, vulnerabilities)

        # Test for IDOR
        self.check_idor(base_url, vulnerabilities)

        # Test for directory listing
        self.check_directory_listing(base_url, vulnerabilities)

        # Test for default credentials
        self.check_default_credentials(base_url, vulnerabilities)

        # Test for insecure data transmission
        self.check_insecure_data_transmission(base_url, vulnerabilities)

        # Test for sensitive data in URL
        self.check_sensitive_data_in_url(base_url, vulnerabilities)

        # Test for clickjacking
        self.check_clickjacking(base_url, vulnerabilities)

        # Test for HTTP response splitting
        self.check_http_response_splitting(action_url, form_details, vulnerabilities)

        # Test for broken access control
        self.check_broken_access_control(base_url, vulnerabilities)

        # Test for insecure deserialization
        self.check_insecure_deserialization(base_url, vulnerabilities)

        # Test for API rate limiting
        self.check_api_rate_limiting(base_url, vulnerabilities)

        # Test for API authorization
        self.check_api_authorization(base_url, vulnerabilities)

        # Test for resource exhaustion (DoS attack)
        self.check_resource_exhaustion(base_url, vulnerabilities)

        # Test for subdomain takeover
        self.check_subdomain_takeover(base_url, vulnerabilities)

        # Test for WebSocket injection
        self.check_websocket_injection(base_url, vulnerabilities)

    def check_session_fixation(self, action_url, form_details, payload, vulnerabilities):
        if 'session' in action_url.lower():
            try:
                response = requests.post(action_url, data=payload)
                if 'Set-Cookie' in response.headers:
                    vulnerabilities.append({
                        'Vulnerability Type': 'Session Fixation',
                        'Target URL': action_url,
                        'Payload': str(payload),
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'Session Fixation Error',
                    'Target URL': action_url,
                    'Response': str(e)
                })

    def check_predictable_login_credentials(self, action_url, form_details, vulnerabilities):
        common_credentials = [
            {'username': 'admin', 'password': 'admin'},
            {'username': 'admin', 'password': 'password'},
            {'username': 'admin', 'password': '1234'},
            {'username': 'user', 'password': 'user'},
            {'username': 'user', 'password': 'password'}
        ]
        for creds in common_credentials:
            try:
                response = requests.post(action_url, data=creds)
                if 'login' in response.text.lower():
                    vulnerabilities.append({
                        'Vulnerability Type': 'Predictable Login Credentials',
                        'Target URL': action_url,
                        'Payload': str(creds),
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'Predictable Login Credentials Error',
                    'Target URL': action_url,
                    'Response': str(e)
                })

    def check_idor(self, base_url, vulnerabilities):
        test_paths = ['admin', 'user']
        for path in test_paths:
            url = urljoin(base_url, path)
            try:
                response = requests.get(url)
                if response.status_code == 200:
                    vulnerabilities.append({
                        'Vulnerability Type': 'Insecure Direct Object Reference (IDOR)',
                        'Target URL': url,
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'IDOR Error',
                    'Target URL': url,
                    'Response': str(e)
                })

    def check_directory_listing(self, base_url, vulnerabilities):
        test_paths = ['/', '/admin/', '/files/']
        for path in test_paths:
            url = urljoin(base_url, path)
            try:
                response = requests.get(url)
                if 'Index of' in response.text:
                    vulnerabilities.append({
                        'Vulnerability Type': 'Directory Listing',
                        'Target URL': url,
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'Directory Listing Error',
                    'Target URL': url,
                    'Response': str(e)
                })

    def check_default_credentials(self, base_url, vulnerabilities):
        common_defaults = [
            {'username': 'admin', 'password': 'admin'},
            {'username': 'admin', 'password': 'password'},
            {'username': 'root', 'password': 'root'}
        ]
        for creds in common_defaults:
            try:
                response = requests.post(base_url, data=creds)
                if 'login' in response.text.lower():
                    vulnerabilities.append({
                        'Vulnerability Type': 'Default Credentials',
                        'Target URL': base_url,
                        'Payload': str(creds),
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'Default Credentials Error',
                    'Target URL': base_url,
                    'Response': str(e)
                })

    def check_insecure_data_transmission(self, base_url, vulnerabilities):
        https_url = base_url.replace('http://', 'https://')
        try:
            response = requests.get(https_url)
            if response.url == https_url:
                vulnerabilities.append({
                    'Vulnerability Type': 'Insecure Data Transmission',
                    'Target URL': base_url,
                    'Response': response.text
                })
        except requests.RequestException as e:
            vulnerabilities.append({
                'Vulnerability Type': 'Insecure Data Transmission Error',
                'Target URL': base_url,
                'Response': str(e)
            })

    def check_sensitive_data_in_url(self, base_url, vulnerabilities):
        test_params = ['?user=test', '?session=123']
        for param in test_params:
            url = urljoin(base_url, param)
            try:
                response = requests.get(url)
                if 'user=' in response.url or 'session=' in response.url:
                    vulnerabilities.append({
                        'Vulnerability Type': 'Sensitive Data in URL',
                        'Target URL': url,
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'Sensitive Data in URL Error',
                    'Target URL': url,
                    'Response': str(e)
                })

    def check_clickjacking(self, base_url, vulnerabilities):
        headers = {
            'X-Frame-Options': 'DENY'
        }
        try:
            response = requests.get(base_url, headers=headers)
            if 'X-Frame-Options' not in response.headers or response.headers['X-Frame-Options'] != 'DENY':
                vulnerabilities.append({
                    'Vulnerability Type': 'Clickjacking',
                    'Target URL': base_url,
                    'Response': response.text
                })
        except requests.RequestException as e:
            vulnerabilities.append({
                'Vulnerability Type': 'Clickjacking Error',
                'Target URL': base_url,
                'Response': str(e)
            })

    def check_http_response_splitting(self, action_url, form_details, vulnerabilities):
        payload = {'input': 'test\r\nSet-Cookie: session_id=malicious; path=/'}
        try:
            response = requests.post(action_url, data=payload)
            if 'Set-Cookie' in response.headers:
                vulnerabilities.append({
                    'Vulnerability Type': 'HTTP Response Splitting',
                    'Target URL': action_url,
                    'Payload': str(payload),
                    'Response': response.text
                })
        except requests.RequestException as e:
            vulnerabilities.append({
                'Vulnerability Type': 'HTTP Response Splitting Error',
                'Target URL': action_url,
                'Response': str(e)
            })

    def check_broken_access_control(self, base_url, vulnerabilities):
        test_urls = ['/admin', '/settings', '/profile']
        for url in test_urls:
            full_url = urljoin(base_url, url)
            try:
                response = requests.get(full_url)
                if response.status_code == 200:
                    vulnerabilities.append({
                        'Vulnerability Type': 'Broken Access Control',
                        'Target URL': full_url,
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'Broken Access Control Error',
                    'Target URL': full_url,
                    'Response': str(e)
                })

    def check_insecure_deserialization(self, base_url, vulnerabilities):
        payload = {'data': 'malicious_payload'}
        try:
            response = requests.post(base_url, json=payload)
            if 'error' in response.text.lower():
                vulnerabilities.append({
                    'Vulnerability Type': 'Insecure Deserialization',
                    'Target URL': base_url,
                    'Payload': str(payload),
                    'Response': response.text
                })
        except requests.RequestException as e:
            vulnerabilities.append({
                'Vulnerability Type': 'Insecure Deserialization Error',
                'Target URL': base_url,
                'Response': str(e)
            })

    def check_api_rate_limiting(self, base_url, vulnerabilities):
        api_endpoints = ['/api/resource']
        for endpoint in api_endpoints:
            for i in range(100):
                try:
                    response = requests.get(urljoin(base_url, endpoint))
                    if response.status_code == 429:
                        vulnerabilities.append({
                            'Vulnerability Type': 'API Rate Limiting',
                            'Target URL': urljoin(base_url, endpoint),
                            'Response': response.text
                        })
                        break
                except requests.RequestException as e:
                    vulnerabilities.append({
                        'Vulnerability Type': 'API Rate Limiting Error',
                        'Target URL': urljoin(base_url, endpoint),
                        'Response': str(e)
                    })

    def check_api_authorization(self, base_url, vulnerabilities):
        api_endpoints = ['/api/secure']
        for endpoint in api_endpoints:
            try:
                response = requests.get(urljoin(base_url, endpoint))
                if response.status_code == 403:
                    vulnerabilities.append({
                        'Vulnerability Type': 'API Authorization',
                        'Target URL': urljoin(base_url, endpoint),
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'API Authorization Error',
                    'Target URL': urljoin(base_url, endpoint),
                    'Response': str(e)
                })

    def check_resource_exhaustion(self, base_url, vulnerabilities):
        try:
            response = requests.get(base_url, timeout=5)
            if response.status_code == 200:
                vulnerabilities.append({
                    'Vulnerability Type': 'Resource Exhaustion (DoS)',
                    'Target URL': base_url,
                    'Response': response.text
                })
        except requests.RequestException as e:
            vulnerabilities.append({
                'Vulnerability Type': 'Resource Exhaustion (DoS) Error',
                'Target URL': base_url,
                'Response': str(e)
            })

    def check_subdomain_takeover(self, base_url, vulnerabilities):
        subdomains = ['test.example.com', 'dev.example.com']
        for subdomain in subdomains:
            url = f"http://{subdomain}"
            try:
                response = requests.get(url)
                if response.status_code == 200:
                    vulnerabilities.append({
                        'Vulnerability Type': 'Subdomain Takeover',
                        'Target URL': url,
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'Subdomain Takeover Error',
                    'Target URL': url,
                    'Response': str(e)
                })

    def check_websocket_injection(self, base_url, vulnerabilities):
        websocket_urls = ['ws://example.com/socket']
        for ws_url in websocket_urls:
            try:
                # This is a simplified check and might not work in a real scenario
                response = requests.get(ws_url)
                if response.status_code == 101:  # Switching Protocols
                    vulnerabilities.append({
                        'Vulnerability Type': 'WebSocket Injection',
                        'Target URL': ws_url,
                        'Response': response.text
                    })
            except requests.RequestException as e:
                vulnerabilities.append({
                    'Vulnerability Type': 'WebSocket Injection Error',
                    'Target URL': ws_url,
                    'Response': str(e)
                })


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec_())
q